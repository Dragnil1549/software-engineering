#include "stdafx.h"  
#include <GL/glut.h>
#include <time.h>
#include <random>
#include <iostream> // подключаем все необходимые инклюды.

int N = 30, M = 20; // т.к. змейка будем ездить по квадратикам, создадим их, для нашего окна в идеале будет 30x20 квадратов
int scale = 25; // размер квадрата. Когда OpenGL будет расчерчивать поле для игры, расстояние между гранями квадрата будет 25 пикселей

int w = scale * N; // ширина поля  
int h = scale * M; // его высота

int dir, num = 4; // 4 направления и начальный размер змеи.
struct { int x; int y; } s[100]; // структура змеи, X и Y координаты, массив с длинной.

class fruct // класс фруктов, тех самых, которые будет есть наша змея
{
public:
	int x, y; //координаты фруктов, что и где будет находится

	void New() // паблик с новыми фруктами. Он будет вызываться в начале игры и в тот момент, когда змея съест один из фруктов
	{
		x = rand() % N; // вычисление X координаты через рандом
		y = rand() % M; // вычисление Y координаты через рандом
	}

	void DrawFruct() // паблик, отрисовывающий фрукты
	{
		glColor3f(0.0, 1.0, 1.0); // цвет фруктов. в openGL он задается от 0 до 1, а не от 0 до 256, как многие привыкли
		glRectf(x * scale, y * scale, (x + 1) * scale, (y + 1) * scale); // "Закрашиваем" квадрат выбранным цветом, таким образом в нем "появляется" фрукт
	}
} m[5]; // масив с фруктами, таким образом, у нас появится одновременно 5 фруктов в разных местах, а не один, как мы привыкли <img src="http://s27.ucoz.net/sm/1/smile.gif" border="0" align="absmiddle" alt="smile" />

void Draw() // функция, которая отрисовывает линии
{
	glColor3f(1.0, 0.0, 0.0); // цвет наших линий, в данном слуае - красный
	glBegin(GL_LINES); // начинаем рисовать и указываем, что это линии
	for (int i = 0; i < w; i += scale) // отрисовываем линии в ширину
	{
		glVertex2f(i, 0); glVertex2f(i, h); // рисуем прямую
	}
	for (int j = 0; j < h; j += scale) //отрисовываем линии в высоту
	{
		glVertex2f(0, j); glVertex2f(w, j); // рисуем ту же самую прямую, но в другом направлении
	}

	glEnd(); // конец отрисовки
}

void tick() // функция в которой будет все обновляться (двигаться змея и т.д.)
{
	for (int i = num; i > 0; --i) // движение змеи. Система остроумна и проста : блок перемешается вперед, а остальные X блоков, на X+1( 2 блок встанет на место 1, 3 на место 2 и т.д...)
	{
		s[i].x = s[i - 1].x; // задаем Х координату i блока координатой i - 1
		s[i].y = s[i - 1].y; // то же самое делаем и с Y координатой
	}
	// далее у нас система направлений.
	if (dir == 0) s[0].y += 1; // если направление равно 0, то первый фрагмент массива перемещается на один по Y
	if (dir == 1) s[0].x -= 1; // если направление равно 1, то первый фрагмент массива перемещается на минус один по X
	if (dir == 2) s[0].x += 1; // аналогиная система
	if (dir == 3) s[0].y -= 1; // аналогичная система

	for (int i = 0; i < 10; i++) //цикл, в котором наша змея будет расти
	{
		if ((s[0].x == m[i].x) && (s[0].y == m[i].y)) // Если голова нашей змеи находится в одном блоке с фруктом, то...
		{
			num++; //...увеличиваем размер нашей змеи на 1
			m[i].New(); // ... запускаем функцию отрисовки нового фрукта.
		}
	}
	// Следующее нужно, что бы змея не выходила за рамка поля. Действует это просто : если змея выходит за рамки поля, то задаем
	if (s[0].x > N) dir = 1; // Ей обратное направление. Например, если она выйдет за экран по высоте, то задаем ей направление, при котором она ползет
	if (s[0].y > M) dir = 3; // вниз
	if (s[0].x < 0) dir = 2;
	if (s[0].y < 0) dir = 0;

	for (int i = 1; i < num; i++) // с помощью этого цикла мы "обрежем" змею, если она заползет сама на себя
		if (s[0].x == s[i].x && s[0].y == s[i].y) // проверка координат частей змеи, если X и Y координата головной части равно координате любого
			num = i; // другого блока змеи, то задаем ей длину, при которой "откушенная" часть отпадает.
}

void Snake() // выводим змейку на экран
{
	glColor3f(0.1, 1.0, 0.0); //цвет змеи
	for (int i = 0; i < num; i++) // цикл отрисовки.
	{
		glRectf(s[i].x * scale, s[i].y * scale, (s[i].x + 0.9) * scale, (s[i].y + 0.9) * scale); //Рисуем квадраты, те самые "блоки" змеи
	}
}

void Key(int key, int a, int b) // функция нажатия клавиш
{
	switch (key) // используем оператор switch
	{
	case 101: dir = 0; break; // при нажатии клавиш, задаем направление змеи(вверх, вниз, влево, вправо)
	case 102: dir = 2; break;
	case 100: dir = 1; break;
	case 103: dir = 3; break;
	}
}

void Display() //функция общий отрисовки
{
	glClear(GL_COLOR_BUFFER_BIT); // очищаем окно перед началом отрисовки

	Draw(); // вызов функции Draw, отвечающей за отрисовку фруктов
	Snake(); // вызов функции Snake, отвечающей за отрисовку змейки

	for (int i = 0; i < 5; i++) // заполнение карты фруктами
		m[i].DrawFruct();

	glFlush(); // выводим на экран все вышеописанное
	glutSwapBuffers();
}

void timer(int = 0) // Таймер игры(промежуток времени, в котором будет производится все процессы)
{
	Display(); // Вызов функций  
	tick();
	glutTimerFunc(100, timer, 0); // новый вызов таймера( 100 - промежуток времени(в милисекундах), через который он будет вызыватся, timer - вызываемый паблик)
}

int main(int argc, char** argv) // Главная функция
{
	std::cout << "Snake by Alexey Ovchinnikov :P\n Loading..."; // крутой текст в консоле при загрузке
	srand(time(0));
	for (int i = 0; i < 10; i++) // начальная, самая первая отрисовка фруктов
		m[i].New();

	s[0].x = 10; // начальное положение змейки по X
	s[0].y = 10; // и Y координате
	// следующие функции абсолютно идиентичных почти во всех программах на OpenGL, так то запоминать их не обязательно, кроме ...
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(w, h); // ... этой, она создаем окно (w - ширина, h - высота)
	glutCreateWindow("Game"); // ... этой, она задает название окна
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 640, 0, 480);
	glutDisplayFunc(Display); // ... и этой, она вызывает начальную функцию, в нашем случае это главная функция отрисовки - Display
	glutSpecialFunc(Key);
	glutTimerFunc(50, timer, 0); // ... Ну и в начале программы задаем рекурсивный таймер.
	glutMainLoop();

	return 0;
}